#include <iostream>
#include <fstream>
#include <string>
#include <filesystem>
#include <cstdlib>

// Helper to parse command-line arguments
struct Args {
    std::string input_html;
    std::string output_cpp;
    bool build = false;
    std::string executable = "generated_app"; // Default executable name
};

Args parse_args(int argc, char** argv) {
    Args args;
    for (int i = 1; i < argc; ++i) {
        std::string arg = argv[i];
        if (arg == "-o" && i+1 < argc) {
            args.output_cpp = argv[++i];
        } else if (arg == "-b" || arg == "--build") {
            args.build = true;
        } else if (arg == "-e" || arg == "--executable" && i+1 < argc) {
            args.executable = argv[++i];
        } else if (args.input_html.empty()) {
            args.input_html = arg;
        } else {
            std::cerr << "Unknown argument: " << arg << "\n";
            exit(1);
        }
    }

    // Validate required args
    if (args.input_html.empty() || args.output_cpp.empty()) {
        std::cerr << "Usage: " << argv[0] << " <input.html> -o <output.cpp> [--build/-b] [--executable/-e <app-name>]\n";
        std::cerr << "Example:\n";
        std::cerr << "  " << argv[0] << " index.html -o app.cpp -b -e harmony_player\n";
        std::cerr << "Flags:\n";
        std::cerr << "  -b/--build      Auto-build the generated C++ file\n";
        std::cerr << "  -e/--executable Name of the final executable (default: generated_app)\n";
        exit(1);
    }
    return args;
}

// Execute build command
bool build_app(const std::string& cpp_file, const std::string& exe_name) {
    // Build command (replace placeholders)
    std::string build_cmd = "clang++-19 " + cpp_file + " -o " + exe_name + 
                            " `pkg-config --cflags --libs webkit2gtk-4.1` " +
                            "-lpthread -ldl -std=c++23 -Wno-c23-extensions";

    std::cout << "\nBuilding app with command:\n" << build_cmd << "\n";
    int exit_code = system(build_cmd.c_str());

    if (exit_code == 0) {
        std::cout << "\n✅ Build successful! Executable: " << exe_name << "\n";
        return true;
    } else {
        std::cerr << "\n❌ Build failed (exit code: " << exit_code << ")\n";
        return false;
    }
}

int main(int argc, char** argv) {
    Args args = parse_args(argc, argv);

    // Validate input HTML
    if (!std::filesystem::exists(args.input_html)) {
        std::cerr << "Error: Input HTML file '" << args.input_html << "' not found!\n";
        return 1;
    }

    // Generate C++ code template
    std::string cpp_code = R"(// Auto-generated by htmlbundlergen
// Build command: clang++-19 $OUTPUT_FILE -o $EXECUTABLE `pkg-config --cflags --libs webkit2gtk-4.1` -lpthread -ldl -std=c++23 -Wno-c23-extensions
#include <cstdlib>
#include <string>
#include <webview/webview.h>

const char embedded_html[] = {
#embed ")" + args.input_html + R"("
    , '\0' 
};

int main() {
  webview::webview wv(true, nullptr);
  // Configure webview
  wv.set_title("selfhosthtmlapp");
  wv.set_size(1000, 700, WEBVIEW_HINT_NONE);

  wv.set_html(embedded_html); // Load embedded HTML
 

  // Run app
  wv.run();
  return 0;
})";

    // Write generated C++ file
    std::ofstream out(args.output_cpp);
    if (!out.is_open()) {
        std::cerr << "Error: Could not create output file '" << args.output_cpp << "'!\n";
        return 1;
    }
    out << cpp_code;
    out.close();
    std::cout << "✅ Generated C++ file: " << args.output_cpp << "\n";

    // Auto-build if requested
    if (args.build) {
        build_app(args.output_cpp, args.executable);
    }

    return 0;
}